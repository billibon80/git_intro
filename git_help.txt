
git config user.name "Guido van Rossum"
git config user.email "guido@python.org"

git config alias.history 'log --graph --oneline --decorate'


Команда git reset откатывает все изменения в текущей ветке до указанной версии коммита. Так можно делать в той ветке, с которой работаете только вы и никто другой. При применении команды переписывается история ветки.
При ресете передаётся один из трёх ключей:
--soft — откатывает изменения до указанного комита. При этом изменения остаются в индексе, будто вы сделали git add, но не закоммитили их.
--mixed (стоит по умолчанию) — аналогичен варианту выше, но изменения уже не будут отслеживаться. Если после ресета выполнить команду git status, то Git предложит добавить изменения командой git add.
--hard — как видно из названия, это самый жёсткий вариант. Он полностью откатывает изменения и заменяет данные в рабочей директории. Все закоммиченные и незакоммиченные изменения удаляются.

Чтобы перейти к состоянию предыдущего коммита, выполните команду git reset --soft HEAD~1. HEAD — это указатель на коммит, на котором вы находитесь. HEAD~1 возвращает хеш предыдущего коммита. То же самое вы можете сделать, скопировав нужный хеш из команды git log: git reset --soft ha1234sh. 
Если вы заглянете в git log, то увидите, что ваш последний коммит пропал из списка. А git status покажет, что все файлы остались в индексе. Нужно убрать оттуда пустой файл reset_help.md. Для этого пригодится команда git rm с параметром --cached — удалить из индекса, но оставить в файловой системе.

git rm --cached reset_help.md

rm file.txt && git rm file.txt --cahched
git rm file.txt
git rm file.txt --force

Чтобы просмотреть разницу между индексом и последним коммитом, выполните команду git diff --staged
или git diff hach_commit_1 hach_commit_2

Вам нужно добавить эти изменения в предыдущий коммит и дать ему новое название. Вы можете сделать это, использовав параметр --amend.

git add .
git commit --amend -m "Добавлена информация о команде reset"

ignore_me.txt          # Игнорировать файл 
app/ignored/           # Игнорировать папку  
*.py[cdo]              # Игнорировать все файлы с расширением pyc/pyd/pyo
app/**/*.log           # Игнорировать log-файлы в app- и поддиректориях 
!app/main.log          # ... кроме файла main.log 

cd .. && rm -r git_intro # copy text
git clone git@github.com:USERNAME/git_intro.git # clone data from repositori github

git log --graph #### 

git-flow ### https://habr.com/ru/company/flant/blog/491320/

git checkout -b feature/branches # создать новую ветку

Команда checkout используется в Git, чтобы:
переключиться на произвольную существующую ветку (git checkout branch-name);
создать новую ветку от текущей (git checkout -b new-branch-name).


При команде checkout Git не даст переключиться на другую ветку, если в текущей есть незакоммиченные изменения. Если вы не хотите коммитить изменения, используйте команду git stash — она их спрячет. Позже изменения можно достать с помощью команд git pop или git apply.


Посмотреть список веток, которые доступны локально, можно командой git branch, а добавив параметр -a, вы увидите ещё и ветки в репозитории GitHub.

git push origin feature/branches

А как работать в консоли?

Сейчас расскажем.
Для начала переключитесь на мастер-ветку и заберите изменения из GitHub.

git checkout master

# Git напомнит вам, что между локальной и удалённой веткой есть различия:
# Switched to branch 'master'
# Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
#  (use "git pull" to update your local branch)
#

git pull
 
А потом создайте новую ветку и внесите правки.

git checkout -b feature/merge

echo "Для слияния двух веток нужна команда merge" > merge_help.md
echo "- [Слияние веток](./merge_help.md)" >> README.md 

Не забывайте проверять статус индекса и добавлять в него файлы.

git status
git add merge_help.md README.md
git commit -m "Добавлена информация о merge"
git log 

Теперь переключитесь на ветку, в которую хотите влить feature/merge и выполните слияние.

git checkout master 

Затем нужно слить изменения ветки feature/merge с основной веткой разработки.

git merge feature/merge 

При желании вы можете отправить локальную мастер-ветку в GitHub командой git push origin branch-name.

Пока вы работаете в одиночку и полностью контролируете код это допустимо. При командной разработке все задачи принято выполнять в отдельных ветках и вливать изменения через pull-request, а master заблокирован для прямого push.

Безопасная отмена изменений

Команда 
git revert 
создаёт новые коммиты, в которых откачены старые изменения. Команду revert обычно используют в публичных ветках — тех, в которых ведут работу несколько человек. Например, её применяют, если кто-то записал в мастер-ветку неработающий код. Также её можно использовать и для своих личных веток.

nano file.txt # open file unix

git mergetool # запускает программу для слияния

